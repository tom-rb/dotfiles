#!/usr/bin/env sh
# Start commit message with issue id from current branch name

# Git calls hook with message file in arg $1 and sometimes a context in $2
file=$1
context=$2

# Don't even try with merge commits
[ "$context" = merge ] && exit 0

# Issue number regex
issue_regex='[A-Z]+-[0-9]+'

# First capture group matches branch prefixes like 'feature/' 'bugfix/' etc.
# Second group matches the desired ABCD-1234 issue id.
issue=$(git symbolic-ref -q --short HEAD | sed -nE "s,([[:alpha:]]+/)*($issue_regex).*,\2,p")

# If branch name has an issue tag
if [ -n "$issue" ]; then
  # Find candidate lines to have the issue tag inserted
  insert_line=$(sed -nE "# [-n]ot print lines by default; use [E]xtended regex
    # [q]uit when scissors are found (search no more lines)
    /-- >8 --/ q;
    # Skip ([d]elete) lines starting with # comment
    /^[[:space:]]*#/ d;
    # When a tag or git message is found, print[c\] 'issue_found' and quit
    /^\\[($issue_regex|[[:alpha:]]+)\\]|^Merge (pull|branch|remote)|^fixup/ {c\
    issue_found
    ;q};
    # Passed the checks above, print line number (=) of a candidate for insertion
    =;
    # If the line is not empty, [q]uit and search no further
    /^[[:space:]]*$/! q
    " "$file" | tail -n 1)
  if [ -n "$insert_line" ] && [ "$insert_line" != issue_found ]; then
    # Insert issue number in selected line (also make .bak backup)
    sed -i.bak -e "${insert_line} s/^/[$issue] /" "$file"
  fi
fi
